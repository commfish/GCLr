run_rubias_mix <- function(reference, mixture, group_names, gen_start_col, method = "MCMC", 
                               alle_freq_prior = list(const_scaled = 1), pi_prior = NA, 
                               pi_init = NULL, reps = 25000, burn_in = 5000, pb_iter = 100, 
                               prelim_reps = NULL, prelim_burn_in = NULL,
                               sample_int_Pi = 10, sample_theta = TRUE, pi_prior_sum = 1, 
                               file = "rubias/output", seed = 56) {
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # This function is a wrapper for `rubias` `infer_mixture` with GCL default settings.
  # It will return the list of 4 tibbles generated by `infer_mixture`
  # It saves three types of output for each mixture (all but "mixing_proportions")
  #
  # Inputs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #   All inputs required for `infer_mixture` are passed on
  #   group_names - character vector of group_names, used to sort repunit as a factor
  #   file - character vector of where to save output from each mixture as a .csv
  #   seed - integer to set the seed for the MCMC
  #
  # Outputs~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #   Returns a dataframe in `rubias` baseline format
  #   Breaks the output into each `mixture_collection` and for each saves as .csv files for posterity:
  #     1) collection level trace, wide format, collections in order of baseline (akin to .BOT file from BAYES)
  #     2) repunit level trace, wide format, repunit in order of `group_names` (akin to .RGN file from BAYES)
  #     3) straight dump of the `indiv_posteriors` tibble (without column `missing_loci`)
  #     4) straight dump of the `bootstrapped_proportions`
  #
  # Example~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # load(".RData")
  # lynncanal_2015 <- run_rubias_mix(reference = , mixture = , gen_start_col = 5, file = "rubias/output)
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  if(!dir.exists(file)) {stop("the file path to save output does not exist, hoser!!!")}
  
  if(sum(names(reference)!=names(mixture))>0){
    
    stop("The reference and mixture data frames differ in structure; check # of columns and variable names. 
         Are you using an old rubias reference object with a new mixture object? 
         Old reference objects may have locus headers with periods replacing hyphens.")
    
  }
  
  if(!(all(group_names %in% unique(reference$repunit)) & all(unique(reference$repunit) %in% group_names))) {
    
    stop("Mismatch between `group_names` and `reference`")
    
  }
  
  if(!is.na(pi_prior) %>% as.vector() %>% unique()){
    
    if(!is.data.frame(pi_prior)|sum(names(pi_prior)%in% c("collection", "pi_param")) < 2 ){
      
      stop("pi_prior must be data frame or tibble with two variables 'collection' and 'pi_param'")
      
    }
    
  }
  
  ### Run infer mixture
  set.seed(seed = seed)
  rubias_out <-
    rubias::infer_mixture(
      reference = reference,
      mixture = mixture,
      gen_start_col = gen_start_col,
      method = method,
      alle_freq_prior = alle_freq_prior,
      pi_prior = pi_prior,
      pi_init = pi_init,
      reps = reps,
      burn_in = burn_in,
      pb_iter = pb_iter,
      prelim_reps = prelim_reps,
      prelim_burn_in = prelim_burn_in,
      sample_int_Pi = sample_int_Pi,
      sample_theta = sample_theta,
      pi_prior_sum = pi_prior_sum
    )
  
  ### Save output
  message("Saving output as .csv files")
  mix_sillys = unique(mixture$collection)
  baseline_pops = unique(reference$collection)  # correctly ordered
  
  ## Save mix_prop_traces
  # Save at collection level
  message("  saving collection traces.", appendLF = FALSE)
  time_coll_trace <- system.time({
    invisible(sapply(mix_sillys, function(mixture) {
      mix_prop_trace_wide_pi <- rubias_out$mix_prop_traces %>%
        dplyr::filter(mixture_collection == mixture) %>%  # filter to mixture
        dplyr::mutate(collection = factor(x = collection, levels = baseline_pops)) %>%  # use factor to order collections same as baseline
        dplyr::select(sweep, collection, pi) %>%  # select only sweep, collection, pi
        tidyr::spread(collection, pi)  # make wide
      readr:: write_csv(x = mix_prop_trace_wide_pi, file = paste0(file, "/", mixture, "_collection_trace.csv"))
    } ))
  })
  message("   time: ", sprintf("%.2f", time_coll_trace["elapsed"]), 
          " seconds")
  
  # Save at repuinit level
  message("  saving repunit traces.", appendLF = FALSE)
  time_repunit_trace <- system.time({
    invisible(sapply(mix_sillys, function(mixture) {
      mix_prop_trace_wide_rho <- rubias_out$mix_prop_traces %>%
        dplyr::filter(mixture_collection == mixture) %>%  # filter to mixture
        dplyr::mutate(repunit = factor(x = repunit, levels = group_names)) %>%  # use factor to order repunit same as group_names
        dplyr::group_by(sweep, repunit) %>% 
        dplyr:: summarise(rho = sum(pi), .groups = "drop") %>% 
        dplyr::select(sweep, repunit, rho) %>%  # select only sweep, collection, pi
        tidyr::spread(repunit, rho)  # make wide
      readr:: write_csv(x = mix_prop_trace_wide_rho, file = paste0(file, "/", mixture, "_repunit_trace.csv"))
    } ))
  })
  message("   time: ", sprintf("%.2f", time_repunit_trace["elapsed"]), 
          " seconds")
  
  ## Save indiv_posteriors
  message("  saving individual posteriors.", appendLF = FALSE)
  time_indiv_posteriors <- system.time({
    invisible(sapply(mix_sillys, function(mixture) {
      indiv_posteriors <- rubias_out$indiv_posteriors %>%
        dplyr::filter(mixture_collection == mixture) %>% 
        dplyr::select(-missing_loci)  # remove this unnecesary list object
      readr:: write_csv(x = indiv_posteriors, file = paste0(file, "/", mixture, "_indiv_posteriors.csv"))
    } ))
  })
  message("   time: ", sprintf("%.2f", time_indiv_posteriors["elapsed"]), 
          " seconds")
  
  ## Save bootstrapped_proportions
  if(method == "PB") {
    message("  saving parametric bootstrap bias corrections.", appendLF = FALSE)
    time_bias <- system.time({
      invisible(sapply(mix_sillys, function(mixture) {
        bias_corr <- rubias_out$bootstrapped_proportions %>%
          dplyr::filter(mixture_collection == mixture)
        readr:: write_csv(x = bias_corr, file = paste0(file, "/", mixture, "_bias_corr.csv"))
      } ))
    })
    message("   time: ", sprintf("%.2f", time_bias["elapsed"]), 
            " seconds")
  }  # PB
  
  return(rubias_out)
}  # end function
---
title: "S242QC"
author: "Andy Barclay"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
packages:
  -GCLr
  -tidyverse
  -plotly
  -DT
---

# Intro
This is an R markdown template for a QC. Once loaded, you simply save the file in the qc directory, fill in a few inputs at the top, then run the code and it will generate a QC summary html.

# Background
The previous QC script consisted of an R script with Excel and other outputs, this exports everything in a single interactive html notebook. The purpose is to keep the QC analysis and results together, in a more reproducible format, while allowing for exporting to Excel, if necessary.


# Additional Script Notes
    
    1) Run this script in order, or some functions will not provide accurate results. This is by design, as this script only hits LOKI once to save time.
    2) Save the file (i.e., name at top is not `Untitled`). 
    3) Add a title and your name to the top of the scrip.
    4) Add your review notes directly below this!


# Lab Review
*Here is a section for laboratory staff to take notes, and give a summary of the QC*

    Author:
    Date:
    Notes:





# Project Leader Review
*Here is a section for project leaders to take notes, and give a summary of the QC*

    Author: Andy Barclay
    Date: 9/5/23
    Notes: Testing QC script






# Inputs
Now we can move onto required user inputs.
*This is the only spot where you need to enter information!*
```{r }
username <- Sys.getenv("USERNAME") # LOKI username 

.password <- scan(path.expand("~/R/usr.pw"), what = "")[2] # LOKI password

dirqc <- "C:/Users/awbarclay/Desktop/Project S242 Copper River Comm_PU_Subs Post Season 2022/QC" # The directory where the QC files are located.

species <- "sockeye" # The species for the project (e.g., "pink").

project <- "S242" # The project name (e.g., "P014").

project_type <- "Biomark" # The type of project ("Biomark", "uSat", or "GT-seq").
```

# Optional inputs
Here are a few more inputs, but are optional and should probably remain the defaults (i.e., do not change unless you know what you are doing.)
```{r}
qc_summary_file <- paste("Project", project,"QC Summary R Script.xlsx") # The file path for the QC summary file; This is automatically generated using `project` (i.e., don't change unless you know what you're doing).

conflict_rate <- 0.10 # The conflict rate threshold at which dupcheck between sillys occurs (default is 0.10).
```

This is for project set up. Do not change.
```{r}
knitr::opts_chunk$set(
  root.dir = dirqc, # set the working directory to dirqc for all subsequent chunks!
  fig.pos = '!h',    # Place figures here and don't float
  fig.width = 12     # Set figure width
)

library(magrittr) #get tidy pipe from this
```

This is a function for making the tables look nice. Do not change.
```{r}
qc_table <- function(x, page.length = NULL){
  DT::datatable(data = x,
    rownames = FALSE,
    filter = "top",
    extensions = "Buttons",
    options = list(dom = 'Bfrtip',
                   pageLength = page.length,
                   buttons =
                     list(
                       'copy',
                       'print',
                       list(
                         extend = 'collection',
                         buttons = c('csv', 'excel'),
                         text = 'Download'
                       )
                     ))
)}
```


Those were all of the user inputs/modifiable sections. The remainder of the script is set up to be run, in order, line by line. Please do not change anything, unless you know what you're doing. Further, if changes are required, it may be worth updating the template so it's fixed for everyone.

# Read Project Genotypes
The next step is to read in the project genotypes from LOKI.

```{r}
GCLr::loki2r_proj(project_name = project, username = username, password = .password)
  
rm(.password) #ditch password since no longer needed

loci <- LocusControl$locusnames # grab list of loci for use later
```

## Calculate Failure Rate
Now we can calculate the failure rate of the project.
```{r}
failure_rate <- GCLr::failure_rate(sillyvec = project_sillys)  
```

### Failure Rate by Silly
This is a table showing the failure rate by silly for the project.
**Chase, maybe we can highlight failure rates above a certain cutoff? (see example below)**
```{r}
failure_rate$silly_failure_rate %>% 
  qc_table() %>% 
  DT::formatStyle('fail', backgroundColor = DT::styleInterval(0.04, c('white', 'red')))
```

And here is a plot showing those data. 
```{r}
failure_rate$plot_silly_failure_rate
```


### Failure Rate by Locus
This is the failure rate by locus for the project.
**Chase, maybe we can highlight failure rates above a certain cutoff? (see example below)**
```{r}
failure_rate$locus_failure_rate %>% 
  qc_table() %>%
  DT::formatStyle('fail', backgroundColor = DT::styleInterval(0.04, c('white', 'red')))
  
```

### Failure Rate by Plate
This is a table showing the failure rate by plate for the project.
**Chase, same as previous comment. **
```{r}
failure_rate$plate_failure_rate %>% 
  qc_table()
```                               

And here is a plot showing those data. 
**Chase, the x-axis gets weird with nonconsecutive plate IDs. I think if you convert the plate number variable to character in GCLr::failure_rate, this won't happen.**
```{r}
failure_rate$plot_plate_failure_rate
```
### Overall Failure Rate
This is the overall failure rate for the project.
```{r}
failure_rate$overall_failure_rate %>% 
  qc_table()
```


# Read in QC Genotypes
Move onto the QC genotypes now. 
    
```{r}
qc_files <-
  list.files(path = "Genotype Data Files", pattern = ".csv", full.names = TRUE, recursive = FALSE)

if (project_type %in% c("Biomark", "uSat","GT-seq")) {
  GCLr::read_qc_geno(qc_csv_filepaths = qc_files, type = project_type)
} else {
  message("project_type must be either 'Biomark', 'uSat', or' GT-seq' to read in qc genotypes")
}

qc_sillys_n <- GCLr::silly_n(sillyvec = qc_sillys)

qc_sillys_n
```
    
# Read in Conflict Report
Now read in the conflict report. 
*Note - old conflict reports have "0" for mitochondrial conflicts while the new has " " for mitochondrial conflicts, we will refer to them as "Homo-Homo".*
```{r}
qc_concordance_report_file <- list.files(path = "Conflict Reports", pattern = "ConcordanceReport", full.names = TRUE)

qc_concordance_report_file #verify it found the file(s)!

GCLr::combine_conflicts(files = qc_concordance_report_file)
```

## Conflict Summaries
The next step is to summarize the conflicts. This will be done a few ways - by plate, by silly, and by loci - which should cover all types of issues you may encounter. 

### By plate
First, we'll take a look at the number of conflicts by plate:
**Chase, maybe highlight homo-homo conflicts?**
```{r}
conflicts_by_plate <- combined_conflicts %>% 
  dplyr::group_by(plate_id, concordance_type) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "keep" ) %>%
  tidyr::pivot_wider(names_from = "concordance_type", values_from = "n",values_fill = 0, names_expand = TRUE) %>% 
  dplyr::mutate(Conflict = sum(`Het-Het`, `Het-Homo`, `Homo-Het`, `Homo-Homo`)) %>%
  dplyr::ungroup()

conflicts_by_plate %>%
  qc_table() %>% 
  DT::formatStyle('Homo-Homo', backgroundColor = DT::styleInterval(0.00, c('white', 'red')))
```

### By SILLY
Next, we'll look at the number of conflicts by silly code.
**Chase, same as last comment**
```{r}
conflicts_by_silly <- combined_conflicts %>% 
  dplyr::group_by(silly, concordance_type) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "keep" ) %>%
  tidyr::pivot_wider(names_from = "concordance_type",values_from = "n", values_fill = 0, names_expand = TRUE) %>%
  dplyr::mutate(Conflict = sum(`Het-Het`, `Het-Homo`, `Homo-Het`, `Homo-Homo`)) %>%
  dplyr::ungroup()

conflicts_by_silly %>% 
  qc_table() %>% 
  DT::formatStyle('Homo-Homo', backgroundColor = DT::styleInterval(0.00, c('white', 'red')))
```

### By locus
Finally, we can look at the number of conflicts by locus.
**Chase, same as last comment** 
```{r}
conflicts_by_locus <- combined_conflicts %>%
  dplyr::group_by(locus, concordance_type) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "keep" ) %>%
  tidyr::pivot_wider(names_from = "concordance_type",values_from = "n", values_fill = 0, names_expand = TRUE) %>%
  dplyr::mutate(Conflict = sum(`Het-Het`, `Het-Homo`, `Homo-Het`, `Homo-Homo`)) %>%
  dplyr::ungroup()

conflicts_by_locus %>% 
  qc_table() %>% 
  DT::formatStyle('Homo-Homo', backgroundColor = DT::styleInterval(0.00, c('white', 'red')))
```
# Sample Sizes by Locus
We'll calculate the sample sizes, by locus, for project and qc genotypes.

## Project Genotypes
```{r}
original_proj_n_by_locus <- GCLr::sampn_by_locus(sillyvec = project_sillys, loci = loci)

original_proj_n_by_locus %>% 
  tidyr::pivot_longer(names_to = "locus", values_to = "n",-silly) %>% 
  qc_table()
```

## QC Genotypes
*Note - you will not get output from this section, unless something fails (i.e., below 0.8)*
**I was a little confused by the output of this chunk. Could it print a message with a list of the failed loci by silly?**
```{r}
original_qc_n_by_locus <-
  GCLr::sampn_by_locus(sillyvec = qc_sillys, loci = loci)

# tibble showing percentage for each locus
original_qc_percent_by_locus <- original_qc_n_by_locus %>%
  dplyr::rowwise() %>%
  dplyr::mutate(across(all_of(loci), ~ . / max(dplyr::c_across(dplyr::all_of(loci)), na.rm = TRUE))) %>%
  tidyr::pivot_longer(cols = -silly, names_to = "loci", values_to = "percent") %>%
  tidyr::pivot_wider(names_from = silly, values_from = percent)

# Are any of these below 80% (i.e., need to be re-run)?
rerunsqc <- which(apply(original_qc_percent_by_locus, 2, min) < 0.8)

# only show results if any of them are below 0.8  i.e., need to be rerun
if (any(original_qc_percent_by_locus %>%
  dplyr::summarize(dplyr::across(dplyr::everything(), ~ any(. < 0.8))))) {
  
  print(original_qc_percent_by_locus %>%
    dplyr::summarize(dplyr::across(dplyr::everything(), ~ any(. < 0.8))))
}

```


Now let's check out a quick plot. This plot is interactive, so you can easily see what's going on - it allows you to zoom, hover over points for info, move around the plot, etc.

**Can the failed loci be highlighted a different color so they stand out?**
```{r}
plotly::ggplotly(
  ggplot2::ggplot(
    original_qc_percent_by_locus %>%
      tidyr::pivot_longer(values_to = "percent", names_to = "silly", -loci),
    ggplot2::aes(x = silly, y = loci)
  ) +
    ggplot2::geom_tile(ggplot2::aes(fill = percent), color = "white") +
    ggplot2::scale_fill_gradient(
      low = "black",
      high = "white",
      limits = c(0, 1)
    ) +
    ggplot2::ylab("Locus") +
    ggplot2::xlab("SILLY") +
    ggplot2::ggtitle("Percent genotyped by silly/locus") +
    ggplot2::labs(fill = "Percent\ngenotyped") +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
)
```

# QA checks
The next step is to conduct QA of the project and qc genotypes. This ensures that we don't have any hidden, or otherwise lurking, bad data. 

## Project Genotypes
Here we'll do QA for the project:

### n genotyped
First calculate the number of fish that were genotyped
```{r}
project_sillys_n <- tibble::tibble(silly = project_sillys) %>% 
   dplyr::mutate(genotyped = GCLr::silly_n(sillyvec = project_sillys) %>% dplyr::pull(n))

project_sillys_n # view sample size table
```

### Alternate Species
Now, we'll check for alternate species. Note that this is only done for chum and sockeye and if there are certain markers in the markersuite. Otherwise, NA is added to the sample size tibble. 

*Note, we're not removing these fish as you would during a normal project (i.e., GCLr::remove_alt_species), as they may be helpful in resolving conflicts. It's also important to note that the sample size is calculated based on assumed defaults, please read the sample size calculation commentary below for details.* 

**This plot needs some explanation, so people understand how to interpret it. Is "alternate" the proportion of alternates that failed or proportion of alternate markers with alternate genotypes?  In the plot below, are the two fish in the upper right hand corner of the plot potential alternates? Maybe highlight circles that are likely alternates?**

**I modified the code to calculate "wrong_spp" for `project_sillys_n`. The original code was applying the same number of wrong species to each silly**
```{r}
# only run if spp = chum or sockeye and the loci are in the list, otherwise nothing to check
if (any(species %in% c("chum", "sockeye")) &
    any(loci %in% c("Oke_U1018-50", "Oke_U2032-74", "Oke_Cr386", "Oke_AhR1-78", "Oke_CKS1-94", "Oke_e2ig5-50", "Oke_U1002-262", "Oke_U1025-135",
        "Oke_u200-385", "Oke_U2025-86", "Oke_U502-241", "One_ctgf-301", "One_KCT1-453", "One_taf12-248", "One_U1013-108", "One_U1214-107", "One_Hsp47", "One_STC-410", "One_U1010-81", "One_MHC2_190", "One_cin-177", "One_vatf-214"))
    ) {
  
  # run alternate species checks
  alternate_spp <-
    suppressMessages(GCLr::find_alt_species(sillyvec = project_sillys, species = species))
  
  # since we're not removing these fish, we must manually calculate the number of alternates. Important to note that we're using a 0.5 cutoff for alternate and failure, as this is the default for GCLr::remove_alt_species(). Any desired changes to the defaults need to be reflected here!
  
  # Chase, I modified this code - A.B. 9/6/23
  n_alts <- alternate_spp %>% 
                    dplyr::mutate(alternate = dplyr::case_when(failure > 0.5 & alternate > 0.5 ~ TRUE,
                                                        TRUE~FALSE)) %>%
                    tidyr::separate(silly_fish, into = c("silly", "fishID")) %>% 
                    dplyr::group_by(silly) %>% 
                    dplyr::summarize(wrong_spp = sum(alternate))
  
  project_sillys_n <- project_sillys_n %>%
    dplyr::left_join(n_alts, by = "silly")
                     
} else {
  # update sample size table with NA if does not meet species or loci criteria
  project_sillys_n <- project_sillys_n %>%
    dplyr::mutate(wrong_spp = NA_integer_)
}

```

 Check out sample size table:
 
 **Are there really 2 alternates per silly? 
```{r}
project_sillys_n  %>% 
  qc_table()# view sample size table
```

Here we can view the table containing failed and alternate markers for each fish. This table shows the proportion of 'failure' and 'alternate' indicator markers that were found for each fish. These data are what's used to determine whether a chum or sockeye was incorrectly identified. 

**Maybe bring the alternates to the top of this table and/or highlight?**
```{r}
alternate_spp %>% 
  qc_table()
```
### Missing (80% rule)
Check for individuals missing \>=20% of genotypes (i.e. the 80% rule). 

*Note that we are removing fish here, since they have poor quality data and are not useful in resolving conflicts.*
```{r}
MissLoci <- GCLr::remove_ind_miss_loci(sillyvec = project_sillys, proportion = 0.8, loci = loci)

project_sillys_n <- project_sillys_n %>%
    dplyr::mutate(missing =  genotyped - GCLr::silly_n(sillyvec = project_sillys) %>% dplyr::pull(n))
```

Check out the sample size table, after removing the fish with poor quality data
```{r}
project_sillys_n %>% 
  qc_table() # view sample size table
```


### Duplicate check.

Remove duplicate individuals within the same collection. Typically we specify duplicates as a pair of individuals that share \>=95% of genotypes. 

*Note that for QC purposes we are not removing any fish, just noting how many per silly. We need to retain all fish, as they may be helpful in resolving conflicts later.*

```{r}
# Run dup check within silly
dup_check_95_minproportion <-
  GCLr::dupcheck_within_silly(
    sillyvec = project_sillys,
    loci = loci,
    quantile = NULL,
    minproportion = 0.95,
    minnonmissing = 0.6,
    ncores = 4,
    LocusCtl = LocusControl
  )

# View dups
dup_check_95_minproportion

#calculate the number of duplicates. First check if the dup check object is 0, and stop there, otherwise, continue and calculate the number of duplicates as the number of unique ID's found in the duplicate check function above. 

n_dups <- dup_check_95_minproportion %>%
        dplyr::mutate(
          remove = dplyr::case_when(
            Missing1 > Missing2 ~ ID1,
            Missing2 > Missing1 ~ ID2,
            Missing1 == Missing2 ~ ID1
          )
        ) %>%
        dplyr::distinct(silly, remove) %>% 
      dplyr::group_by(silly) %>% 
      dplyr::summarise(duplicate = length(remove))

(project_sillys_n <- project_sillys_n %>%
  dplyr::left_join(n_dups, by = "silly") %>% 
  tidyr::replace_na(replace = list(duplicate = 0)))
  
  
```

Check out the sample size table, after checking for duplicates
```{r}
project_sillys_n %>% 
  qc_table() # view sample size table
```

### Final Sample Size
**Chase, it might be good to make the datatable code a function since it's repeated many times throughout this script. I created an example function in the chunk below.**
```{r}
project_sillys_n <- project_sillys_n %>%
    dplyr::mutate(final = genotyped - wrong_spp - missing - duplicate)


# view sample size table
qc_table(project_sillys_n)

```


## QC Genotypes
Here we'll do QA for the QC extractions. We're not calculating the full sample sizes, etc., as shown above, simply dealing with missing loci (looking for no more than 20% loss).

```{r}
miss_loci_qc <- GCLr::remove_ind_miss_loci(sillyvec = qc_sillys, proportion = 0.8)
```
  
# Perform Duplicate Check on High Conflict Individuals
The last step in the process is to perform a duplicate check on any individuals which show a high degree of conflicts.
```{r}
# Filter for conflicts, determine conflict rate
conflicts <- combined_conflicts %>%
  dplyr::filter(concordance_type %in% c("Het-Het", "Het-Homo", "Homo-Het", "Homo-Homo")) %>%
  dplyr::count(SillySource) %>%
  dplyr::mutate(p = n / length(loci))

# Plot a histogram of conflict rate
conflicts %>%
  ggplot2::ggplot(ggplot2::aes(x = p)) +
  ggplot2::geom_bar() +
  ggplot2::xlim(0, 1) +
  ggplot2::geom_vline(xintercept = conflict_rate,
                      colour = "red",
                      lwd = 1.5) +
  ggplot2::xlab("Conflict Rate") +
  ggplot2::ylab("Frequency") +
  ggplot2::ggtitle("QC Individual Conflict Rate")
```
Now identify anything to investigate by running a duplicate check on anything with high degree of conflicts
```{r}

(dup_check_results <- GCLr:::dupcheck_qc_conflicts(conflicts = conflicts, conflict_rate = conflict_rate, project_sillys = project_sillys))

```

We can take a look at the duplicate check results. Note that if the section above notes that there are no individuals with > 10% loci with conflicts between project and qc, this table will say "Not applicable".
```{r}
dup_check_results %>% 
  qc_table()
```


This concludes the QA section. At this point, you should have all the information necessary to decide if there are issues with the project or QC extractions! 



# Summary Tables
Now that we've ensured the project and qc data match, after accounting for unreliable individuals, we can generate summary tables of the results. There are a series of tables, all displaying different data that were calculated above. 


## Summary By Silly
Here is a table that shows an overall summary, by silly, for the project.
                                         
```{r}
summary_by_silly <-
  project_sillys_n %>%
  dplyr::left_join(failure_rate$silly_failure_rate, by = "silly") %>%
  dplyr::rename("Failure Rate" = fail) %>%
  dplyr::mutate("Total qc Fish" = qc_sillys_n %>% 
                  dplyr::pull(n))

summary_by_silly %>% 
  qc_table()
```
## Conflicts by Silly
Here is a table that shows the conflicts, by silly, for the project.

**Chase, I don't think you need to factor silly in the qc_silly_genotypes. I think it was to make sure things lined up when combining objects in the old script. The new tidy code takes care of this issue.**
```{r}
qc_silly_genotypes <- 
  tibble::tibble(silly = project_sillys) %>% # does this need to be factored? old script had it, I don't think it's needed
  dplyr::left_join(qc_sillys_n %>%
                     dplyr::mutate(silly = stringr::str_remove(silly, pattern = "qc$")),
                   by = "silly") %>%
  dplyr::mutate(qc_genotypes = dplyr::case_when(is.na(n) ~ 0,
                                     TRUE ~ n) *
                  length(loci)) %>% 
  dplyr::select(-n)
                
                 
conflicts_by_silly_qc <- conflicts_by_silly %>%
  tidyr::pivot_longer(names_to = "type", values_to = "number",-silly) %>% 
  dplyr::left_join(qc_silly_genotypes, by = "silly") %>%  # join number of qc genotypes by silly
  dplyr::mutate(rate = number / qc_genotypes) %>%  # conflict numbers to rates
  tidyr::pivot_longer(names_to = "variable", values_to = "value",cols = -c("silly","qc_genotypes","type")) %>%  # make tall
  tidyr::unite(temp, type, variable) %>%  # unite conflict type with both number and rate
  tidyr::pivot_wider(names_from = "temp",values_from = "value") %>%  # make wide
  dplyr::select(
    Silly = silly,
    "Total qc Genotypes" = qc_genotypes,
    "Total Discrepancies" = Conflict_number,
    "Discrepancy Rate" = Conflict_rate,
    "DB Zeros" = `DB Zero_number`,
    "DB Zero Rate" = `DB Zero_rate`,
    "qc Zeros" = `File Zero_number`,
    "qc Zero Rate" = `File Zero_rate`,
    "Total Het-Het" = `Het-Het_number`,
    "Het-Het Rate" = `Het-Het_rate`,
    "Total Het-Homo" = `Het-Homo_number`,
    "Het-Homo Rate" = `Het-Homo_rate`,
    "Total Homo-Het" = `Homo-Het_number`,
    "Homo-Het Rate" = `Homo-Het_rate`,
    "Total Homo-Homo" = `Homo-Homo_number`,
    "Homo-Homo Rate" = `Homo-Homo_rate`
  )

conflicts_by_silly_qc %>% 
  qc_table()
```

## Conflicts by Locus
Here is a table that shows the conflicts by locus for the project.
```{r}
conflicts_by_locus_qc <- conflicts_by_locus %>%
  tidyr::pivot_longer(names_to = "type", values_to = "number", -locus) %>%  # make tall
  dplyr::mutate(qc_genotypes = sum(qc_sillys_n %>% 
                                     dplyr::pull(n))) %>%  # join number of qc genotypes by locus
  dplyr::mutate(rate = number / qc_genotypes) %>%  # conflict numbers to rates
  tidyr::pivot_longer(names_to = "variable", values_to = "value",cols = -c("locus","qc_genotypes","type")) %>% 
  tidyr::unite(temp, type, variable) %>%  # unite conflict type with both number and rate
  tidyr::pivot_wider(names_from = "temp",values_from = "value") %>%  # make wide
  dplyr::select(
    Locus = locus,
    "Total qc Genotypes" = qc_genotypes,
    "Total Discrepancies" = Conflict_number,
    "Discrepancy Rate" = Conflict_rate,
    "DB Zeros" = `DB Zero_number`,
    "DB Zero Rate" = `DB Zero_rate`,
    "qc Zeros" = `File Zero_number`,
    "qc Zero Rate" = `File Zero_rate`,
    "Total Het-Het" = `Het-Het_number`,
    "Het-Het Rate" = `Het-Het_rate`,
    "Total Het-Homo" = `Het-Homo_number`,
    "Het-Homo Rate" = `Het-Homo_rate`,
    "Total Homo-Het" = `Homo-Het_number`,
    "Homo-Het Rate" = `Homo-Het_rate`,
    "Total Homo-Homo" = `Homo-Homo_number`,
    "Homo-Homo Rate" = `Homo-Homo_rate`
  )

conflicts_by_locus_qc %>% 
  qc_table()
```

# Save Workspace
This concludes the QC script. Let's save the RData.
```{r}
save.image(file = paste0(dirqc, project,"_QC.RData"))
```

# Save Document

Once you've run through this script and have added comments to the top, you can save the document. This will also render an html file that you'll want to rename for. 

*There are a few ways to do this and you only need to pick one*

**Chase, saving the .Rmd only produces an .html if you click the "Knit on Save" box or you are saving a 'html_notebook'**
**Maybe option 1 could be to click the Knit button and then change the name of the html?**
Option 1 - 

    1) File > Save (or Control + S or the little "Save" icon on the top bar)
    2) Navigate to the QC directory in Windows Explorer
    3) Rename the .html to "project_qc_final.html"
    

Option 2 - 
An alternate option is to run the code below, which will rerun everything and make your notebook.This is also handy if you just wanted to run the entire qc...use at your own risk.
**Chase, using rmarkdown::render() doesn't work for folding the code, but clicking the Knit button works perfectly.**
```{r eval=FALSE}
rm(list = setdiff(ls(), c("project","dirqc"))) # remove everything except for project and dirqc


rmarkdown::render(input = paste0(project,"QC.Rmd"),
                  output_file = paste0(project, "_qc_final.html"),
                  output_dir = dirqc,
                  output_format = rmarkdown::html_document(toc = TRUE, toc_float = TRUE, code_folding = "hide")
) # save html document to the qc directory
```

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_rubias_base_eval.r
\name{run_rubias_base_eval}
\alias{run_rubias_base_eval}
\alias{run_rubias_baseline_eval.GCL}
\title{Run Rubias Baseline Evaluation Tests}
\usage{
run_rubias_base_eval(
  tests,
  group_names,
  gen_start_col = 5,
  base.path = "rubias/baseline",
  mix.path = "rubias/mixture",
  out.path = "rubias/output",
  method = "MCMC",
  alle_freq_prior = list(const_scaled = 1),
  pi_prior = NA,
  pi_init = NULL,
  reps = 25000,
  burn_in = 5000,
  pb_iter = 100,
  prelim_reps = NULL,
  prelim_burn_in = NULL,
  sample_int_Pi = 10,
  sample_theta = TRUE,
  pi_prior_sum = 1,
  seed = 56,
  ncores = 4,
  file_type = c("fst", "csv")[1]
)

run_rubias_baseline_eval.GCL(
  tests,
  group_names,
  gen_start_col = 5,
  base.path = "rubias/baseline",
  mix.path = "rubias/mixture",
  out.path = "rubias/output",
  method = "MCMC",
  alle_freq_prior = list(const_scaled = 1),
  pi_prior = NA,
  pi_init = NULL,
  reps = 25000,
  burn_in = 5000,
  pb_iter = 100,
  prelim_reps = NULL,
  prelim_burn_in = NULL,
  sample_int_Pi = 10,
  sample_theta = TRUE,
  pi_prior_sum = 1,
  seed = 56,
  ncores = 4,
  file_type = c("fst", "csv")[1]
)
}
\arguments{
\item{tests}{a tibble produced by \code{\link[=base_eval_sample_sizes]{base_eval_sample_sizes()}} containing \code{test_group} and \code{scenario}}

\item{group_names}{a character vector of group names, used to sort \code{repunit} as a factor}

\item{gen_start_col}{an integer indicating the starting column index for genetic data in the mixture and baseline files (default: 5)}

\item{base.path}{the file path where the baseline .csv files are located}

\item{mix.path}{the file path where the mixture .csv files are located}

\item{out.path}{the file path to save output from each mixture as a .csv}

\item{method}{a choice among "MCMC", "PB", and "BR" methods for estimating mixture proportions (see details)}

\item{alle_freq_prior}{a one-element named list specifying the prior to be used when generating Dirichlet parameters for genotype likelihood calculations. Valid methods include "const", "scaled_const", and "empirical". See \code{?rubias::list_diploid_params()} for method details. (default: list(const_scaled = 1))}

\item{pi_prior}{The prior to be added to the collection allocations, in order to generate pseudo-count Dirichlet parameters for the simulation of new pi vectors in MCMC. Default value of NA leads to the calculation of a symmetrical prior based on pi_prior_sum. To provide other values to certain collections, you can pass in a data frame with two columns, "collection" listing the relevant collection, and "pi_param" listing the desired prior for that collection (see \code{\link[=create_prior]{create_prior()}}. Specific priors may be listed for as few as one collection. The special collection name "DEFAULT_PI" is used to set the prior for all collections not explicitly listed; if no "DEFAULT_PI" is given, it is taken to be 1/(# collections).}

\item{pi_init}{The initial value to use for the mixing proportion of collections. This lets the user start the chain from a specific value of the mixing proportion vector. If pi_init is NULL (the default) then the mixing proportions are all initialized to be equal. Otherwise, you pass in a data frame with one column named "collection" and the other named "pi_init" (see \code{\link[=random_inits]{random_inits()}}. Every value in the pi_init column must be strictly positive (> 0), and a value must be given for every collection. If they sum to more than one the values will be normalized to sum to one.}

\item{reps}{the number of MCMC iterations (default: 25000)}

\item{burn_in}{how many iterations to discard in the beginning of MCMC when doing the mean calculation. They will still be returned in the traces if desired. (default: 5000)}

\item{pb_iter}{how many bootstrapped data sets to do for bootstrap correction using method PB. (default: 100)}

\item{prelim_reps}{for method "BR", the number of reps of conditional MCMC (as in method "MCMC") to perform prior to MCMC with baseline resampling. The posterior mean of mixing proportions from this conditional MCMC is then used as pi_init in the baseline resampling MCMC (default: NULL)}

\item{prelim_burn_in}{for method "BR", this sets the number of sweeps out of prelim_reps that should be discarded as burn in when preparing the posterior means of the mixing proportions to be set as pi_init in the baseline resampling MCMC. (default: NULL)}

\item{sample_int_Pi}{how many iterations between storing the mixing proportions trace. Can't be 0. Can't be so large that fewer than 10 samples are taken from the burn in and the sweeps. (default: 10)}

\item{sample_theta}{for method "BR", whether or not the function should store the posterior mean of the updated allele frequencies. (default: TRUE)}

\item{pi_prior_sum}{For pi_prior = NA, the prior on the mixing proportions is set as a Dirichlet vector of length C, with each element being W/C, where W is the pi_prior_sum and C is the number of collections. By default this is 1. If it is made much smaller than 1, things could start to mix more poorly. (default: 1)}

\item{seed}{An integer to set the seed for the MCMC (default: 56)}

\item{ncores}{A numeric vector of length one indicating the number of cores to use (default: 4)}

\item{file_type}{The file type of the baseline and mixture input files, either "fst" or "csv" (default: "fst")(see details).}
}
\value{
This function breaks up the \emph{rubias} output by mixture_collection and for each mixture the following are saved as .csv or .fst files:
\itemize{
\item collection level trace, wide format, collections in order of baseline - akin to .BOT file from BAYES
\item repunit level trace, wide format, repunit in order of \code{group_names} - akin to .RGN file from BAYES
\item straight dump of the \code{indiv_posteriors} tibble - without column \code{missing_loci}
\item straight dump of the \code{indiv_posteriors} tibble - without column \code{missing_loci}
\item straight dump of the \code{bootstrapped_proportions}
}
}
\description{
This function is a wrapper for \code{\link[=run_rubias_mix]{run_rubias_mix()}}. It runs baseline evaluation mixtures produced by \code{\link[=create_rubias_base_eval]{create_rubias_base_eval()}} and multicores by test group. i.e., mixtures for a test group are run on a different core simultaneously.
It is designed for use on a server with many cores and ample RAM.
}
\details{
"MCMC" estimates mixing proportions and individual posterior probabilities of assignment through Markov-chain Monte Carlo conditional on the reference allele frequencies, while "PB" does the same with a parametric bootstrapping correction, and "BR" runs MCMC sweeps while simulating reference allele frequencies using the genotypes of mixture individuals and allocations from the previous sweep. All methods default to a uniform 1/(# collections or RUs) prior for the mixing proportions.
The function can read in .csv or .fst files.  .fst files are compressed, so they save hard drive space, and they are faster to save and read back into R. .csv is also an option to make the function backwards compatible with older analyzes that produced .csv files.
}
\examples{
   attach("C:/Users/awbarclay/Documents/Analysis/Chinook/Susitna_Chinook_baseline_2020/run baseline eval tests/Susitna_Chinook_baseline_2020_noGTseq.Rdata")
   Final_Pops <- Final_Pops \%>\% mutate(group = factor(group, levels = unique(group)))
   sample_sizes <- base_eval_sample_sizes(sillyvec = Final_Pops$silly, group_names = Final_Pops$group \%>\% levels(), groupvec = Final_Pops$group \%>\% as.numeric(), scenarios = round(seq(.01, 1, .01), 2), mixsize = 200, maxprop = 0.5, seed = 123)
   create_rubias_base_eval(sillyvec = Final_Pops$silly, group_names = Final_Pops$group \%>\% levels(), test_groups = Final_Pops$group \%>\% levels(), loci = loci80, groupvec = Final_Pops$group \%>\% as.numeric(), sample_sizes = sample_sizes, prprtnl = TRUE, seed = 123, ncores = 8)
   tests <- sample_sizes \%>\% group_by(test_group, scenario) \%>\% summarize(test_group = test_group \%>\% unique(), scenario = scenario \%>\% unique(), .groups = "drop_last")
   run_rubias_base_eval(tests = tests, group_names = Final_Pops$group \%>\% levels(), gen_start_col = 5, base.path = "rubias/baseline",mix.path = "rubias/mixture", out.path = "rubias/output", seed = 56, ncores = 8)
   
}

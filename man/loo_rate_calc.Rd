% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loo_roc_rate_calc.R
\name{loo_rate_calc}
\alias{loo_rate_calc}
\alias{loo_roc_rate_calc}
\title{Calculate Error Rates for Receiver Operator Characteristic (ROC) Curve Plots}
\usage{
loo_rate_calc(
  data,
  thres_levels,
  group_names,
  ncores = parallel::detectCores()
)
}
\arguments{
\item{data}{the unmodified output from \code{\link[rubias:self_assign]{rubias::self_assign()}}}

\item{thres_levels}{the assignment thresholds levels that you want to plot}

\item{group_names}{the reporting group names}

\item{ncores}{A numeric value for the number of cores to use.}
}
\value{
This function produces a tibble 10 variables:
\itemize{
\item \code{repunit} (character): reporting group
\item \code{fn} (integer): number of false negative assignments
\item \code{tn} (integer): number of true negative assignments
\item \code{tp} (integer): number of true positive assignments
\item \code{fp} (integer): number of false positive assignments
\item \code{tpr} (double): the true positive assignment rate - tp / (tp + fn)
\item \code{fpt} (double): the false positive assignment rate - fp / (fp + tn)
\item \code{acc} (double): accuracy rate - (tp + tn) / (tp + tn + fp + fn)
\item \code{pre} (double): precision rate - tp / (tp + fp)
\item \code{level} (double): the assignment threshold level (proportion)
\item \code{threshold} (character): the assignment threshold level (percent) for ROC curve plots.
}
}
\description{
This function takes the leave-one-out output from \code{\link[rubias:self_assign]{rubias::self_assign()}} and calculates true positive, false negative, false positive, and true negative assignment error rates for each reporting group.
The output from this function can then be used to create a Receiver Operator Characteristic curve plot for determining an appropriate individual assignment threshold and whether a reporting group is sufficiently identifiable for producing individual assignment estimates.
}
\note{
Depending on how large your baseline data set is, this function can take a long time to run.
If you want to be able to work on your computer while the function is running make sure to set \code{ncores} below the total number of cores on your machine.
}
\examples{

 Self_Assign <- rubias::self_assign(reference = GCLr::ex_baseline, gen_start_col = 5)

 groups <- GCLr::ex_baseline$repunit \%>\% unique()

 loo_rate_calc(data = Self_Assign, thres_levels = seq(0.5, .99, by = 0.01), group_names = groups, ncores = 3)
 
}
\seealso{
\code{\link[rubias:self_assign]{rubias::self_assign()}}
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summarize_rubias_base_eval.r
\name{summarize_rubias_base_eval}
\alias{summarize_rubias_base_eval}
\title{Summarize \code{rubias} Baseline Evaluation Tests}
\usage{
summarize_rubias_base_eval(
  mixvec,
  sample_sizes,
  method = c("MCMC", "PB", "both")[1],
  group_names = NULL,
  group_names_new = NULL,
  groupvec = NULL,
  groupvec_new = NULL,
  path = "rubias/output",
  alpha = 0.1,
  burn_in = 5000,
  threshold = 5e-07,
  ncores = 4
)
}
\arguments{
\item{mixvec}{A character vector of test mixture names.}

\item{sample_sizes}{A tibble produced by \code{\link[=base_eval_sample_sizes]{base_eval_sample_sizes()}} containing the following variables:
\code{test_group}, \code{scenario}, \code{repunit}, and \code{samps}.}

\item{method}{A character vector of length 1 indicating the \pkg{rubias} output to summarize:
"MCMC" (summarize MCMC output), "PB" (summarize bias corrected output), "both" (summarize both outputs); (default = "MCMC)}

\item{group_names}{An optional character vector of group names, used to sort \code{repunit} as a factor, passes through
to \code{\link[=custom_comb_rubias_output]{custom_comb_rubias_output()}} (default = \code{NULL}). If \code{NULL}, \code{group_names} comes from \code{repunit_trace.csv} output files.}

\item{group_names_new}{An optional character vector of new \code{group_names}, used to roll up groups from fine-scale \code{repunit} to broad-scale
\code{repunit} for bias correction, passes through to \code{\link[=custom_comb_rubias_output]{custom_comb_rubias_output()}} (default = \code{NULL}).}

\item{groupvec}{An optional numeric vector indicating the group affiliation of each pop in the baseline \code{sillyvec}, used if
accessing \code{collection_trace.csv} output files to re-summarize to new groups (default = \code{NULL}). If \code{NULL}, \code{group_names} comes
from \code{repunit_trace.csv} output files.}

\item{groupvec_new}{An optional numeric vector indicating the new broad-scale group affiliation of each fine-scale group,
used if accessing \code{repunit_trace.csv} output files to re-summarize fine-scale groups to broad-scale groups with bias correction
(\code{method = "PB"}; default = \code{NULL}). If \code{NULL}, \code{group_names} comes from \code{repunit_trace.csv} output files.}

\item{path}{A character vector of where to find output from each mixture as a .csv (created by \code{\link[=run_rubias_base_eval]{run_rubias_base_eval()}};
default is "rubias/output").}

\item{alpha}{A numeric vector of length 1 specifying credibility intervals (default is 0.1, which gives 90\% CIs (i.e., 5\% and 95\%)).}

\item{burn_in}{A numeric vector of length 1 specifying how many sweeps were used for burn_in in \code{\link[=run_rubias_base_eval]{run_rubias_base_eval()}}
(default = 5000).}

\item{threshold}{A numeric vector of length 1 specifying how low stock comp is before assume 0, used for \code{P=0} calculation, (default = 5e-7).}

\item{ncores}{An optional numeric value for the number of cores to use in a \pkg{foreach} \verb{\%dopar\%} loop (default = 4).
If the number of cores exceeds the number on your device (\code{\link[parallel:detectCores]{parallel::detectCores()}}), then all cores will be used. Note that \code{ncores} is
only used if \code{method = "both"}.}
}
\value{
A list with the following 2 components:
\itemize{
\item \code{estimates}: a tibble with 11 columns containing all group-level stock proportion output:
\itemize{
\item \code{test_group}: \code{repunit} being tested
\item \code{scenario}: stock proportion of \code{repunit} being tested
\item \code{repunit}: group name
\item \code{mean}: mean posterior of stock proportion
\item \code{sd}: sd of posterior of stock proportion
\item \code{lo5CI}: lower 5\% CI from posterior of stock proportion
\item \code{hi95CI}: upper 95\% CI from posterior of stock proportion
\item \code{P=0}: proportion of posterior with stock proportion < \code{threshold} (i.e., 0)
\item \code{true_proportion}: the true stock proportion in  the scenario
\item \code{total_samples}: mixture scenario sample size
\item \code{method}: \pkg{rubias} method ("MCMC" or "PB")
}
\item \code{summary_stats}: a tibble with 6 columns containing mixture summary statistics for each group tested:
\itemize{
\item \code{method}: \pkg{rubias} method ("MCMC" or "PB")
\item \code{test_group}: \code{repunit} being tested
\item \code{RMSE}: root mean squared error of mean stock proportions
\item \code{Mean_Bias}: mean bias (estimate - true) among all test mixtures for a given \code{test_group}
\item \code{90%_within}: the |90% CI| of the residuals (i.e., 90% of point estimates were within d distance of the true proportion)
          \item \code{Within_Interval}: the proportion of tests where the CI contained the true proportion
        }
}
}
\description{
Thus function is a wrapper for \code{\link[=custom_comb_rubias_output]{custom_comb_rubias_output()}} to summarize \pkg{rubias} output from baseline
evaluation tests after running \code{\link[=run_rubias_base_eval]{run_rubias_base_eval()}}.
}
\details{
Thus function is the final step in baseline evaluations tests using \pkg{rubias}. The normal workflow uses: \code{\link[=base_eval_sample_sizes]{base_eval_sample_sizes()}}
to determine leave-one-out sample sizes for tests, then \code{\link[=create_rubias_base_eval]{create_rubias_base_eval()}} generates the necessary \pkg{rubias} .csv files, which
are then analyzed/run in parallel by \code{\link[=run_rubias_base_eval]{run_rubias_base_eval()}} to create output .csv files, and finally summarized by \code{\link[=summarize_rubias_base_eval]{summarize_rubias_base_eval()}}.
}
\examples{
\dontrun{
base_eval_out <- GCLr::summarize_rubias_base_eval()
}

}
\seealso{
\code{\link[=custom_comb_rubias_output]{custom_comb_rubias_output()}}
\code{\link[=base_eval_sample_sizes]{base_eval_sample_sizes()}}
\code{\link[=create_rubias_base_eval]{create_rubias_base_eval()}}
\code{\link[=run_rubias_base_eval]{run_rubias_base_eval()}}
\code{\link[rubias:rubias]{rubias::rubias()}}
}
